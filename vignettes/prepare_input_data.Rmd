---
title: "Prepare input data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Prepare input data}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  markdown: 
    wrap: 72
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette describes how to generate input data for running wavess
using functions from the package, as summarized in the table below.
Please note that you may also generate the input data on your own, which
may be necessary if your inputs require more customization than these
functions provide. However, we expect these functions to be sufficient
for most users.

| `run_wavess()` argument | `wavess` function to generate input | Description of input |
|------------------------|------------------------|------------------------|
| `pop_samp` | `generate_pop_samp()` | [Define active cell growth and sampling](#define-active-cell-growth-and-sampling) |
| `founder_seqs` | `extract_seqs()` | [Extract founder sequence from an alignment](#extract-founder-sequence-from-an-alignment) |
| `nt_sub_probs` | `calc_nt_sub_probs()` | [Determine nucleotide substitution probabilities](#determine-nucleotide-substitution-probabilities) |
| `prob_*` | `rate_to_prob()` | [Convert rate to probability](#convert-rate-to-probability) |
| `conserved_sites` | `identify_conserved_sites()` | [Identify conserved sites](#identify-conserved-sites) |
| `ref_seq` | `identify_conserved_sites()`, `extract_seqs()` | Reference sequence that is considered to be the best replicator |
| `epitope_locations` | `get_epitope_frequencies()`, `sample_epitopes()` | Sample epitopes |

Each of the sections below goes into more detail.

We also provide a final section on how to visualize [latent cell
dynamics](#visualize-latent-cell-dynamics).

## Install and load `wavess`

First, you need to install (if needed) and load the `wavess` library, as
well as a few others:

```{r load}
# install.packages("remotes")
# remotes::install_github("MolEvolEpid/wavess")
# install.packages("ggplot2")

library(wavess)
library(dplyr)
library(tidyr)
library(ggplot2)
library(ape)
```

This will also load some example data that we will be using in this
vignette. All of this example data is related to the HIV gp120 protein.
Please note that the default parameters for `run_wavess()` are also based on 
this example.

In particular, we include the following example data in the package:

- `hxb2_cons_founder`: an alignment in `ape::DNAbin` format that includes
  the HIV full-genome sequence for the HXB2 reference sequence, the consensus 
  sequence, and an example founder sequence.
- `hiv_env_flt_2021`: the first 10 sequences from the filtered HIV ENV alignment 
downloaded from the [LANL HIV sequence
  database](https://www.hiv.lanl.gov/content/sequence/NEWALIGN/align.html),
  in `ape::DNAbin` format. Feel free to download the entire alignment if you'd like.
- `env_features`: a tibble of binding, contact, and and neutralization
  features for HIV ENV from the [LANL HIV immunology
  database](https://www.hiv.lanl.gov/components/sequence/HIV/neutralization/download_db.comp).

You can check out the documentation for these datasets for more details.

If you want to load your own data, you can use `ape::read.dna()` or 
`ape::read.FASTA()` to load alignment files and `readr::read_delim()` to load 
delimited files. 

## Required `run_wavess()` inputs

The three required inputs to `run_waves()` are a data frame of the infected 
cell effective population size and sampling scheme per generation (`pop_samp`), a vector
of the founder sequence(s) in character string format (`founder_seqs`), and a
data frame of nucleotide substitution probabilities (`nt_sub_probs`). In this
section, we will introduce functions that can help generate these inputs.

### Define active cell growth and sampling {#define-active-cell-growth-and-sampling}

`run_wavess()` requires a `pop_samp` data frame as input where each row
is a generation with the following columns:

- `generation`: Each generation to be simulated (must be consecutive
  whole numbers starting with 0)
- `active_cell_count`: Number of active infected cells in each generation
- `n_sample_active`: Number of sequences to sample in each generation
  (must be â‰¤ `active_cell_count`)

You can create this data frame yourself, but we also provide a helper
function to generate it: `generate_pop_samp()`.

All of the arguments in this function have defaults, so you can run:

```{r, generate_pop_samp}
generate_pop_samp()
```

By default, the infected cell population growth follows a logistic
growth curve (`curve_type`) starting with a population of 1 (`n0`) and a
carrying capacity of 2000 (`K`), the simulation is run for 3000
generations (`gN`), and a maximum of 20 sequences (`max_samp`) are
sampled every 300 generations (`sampling_frequency`).
All of these defaults can be changed by altering the input parameters of
the function. The curve type can be defined as "logistic" or "linear".
In addition to the parameters described above, when defining a logistic
growth curve, one additional parameters (`g50`) can be altered to modify
the shape of the curve. See the `generate_pop_samp()` function
documentation for more details.

Here is an example where there are fewer generations, but more frequent
sampling and more samples taken at each sampling event:

```{r, generate_pop_samp2}
(pop_samp <- generate_pop_samp(gN = 500, sampling_frequency = 30, max_samp = 50))
```

A couple notes:

- Assuming everything else remains the same, the maximum population size simulated 
greatly influences the simulation output. 
- The default starts with 1 active cell in generation 0, which means 
that no multiple infections can occur. If multiple founders are provided, one
would be randomly chosen to start the simulation.

You can visualize the active cell dynamics over time using the following
code, where the black line is the effective population size and the 
red dots are the number of samples taken:

```{r, plot_counts}
# plot active cell counts
pop_samp |> 
  # to only plot the number of samples taken when it's not 0
  mutate(n_sample_active = ifelse(n_sample_active == 0, NA, n_sample_active)) |> 
  ggplot(aes(x = generation, y = active_cell_count)) +
  geom_line() +
  geom_point(aes(x = generation, y = n_sample_active), col = 'red') +
  labs(x = 'Generation', y = 'Number of infected active cells')
```

### Extract founder sequence from an alignment {#extract-founder-sequence-from-an-alignment}

`run_wavess()` takes as input a character vector of founder sequence(s)
(`founder_seqs`). All sequences must be the same length and not contain
gaps.

We provide the function `extract_seqs()` to extract a founder
sequence from an alignment in `ape::DNAbin` format and convert it into a
character vector. The alignment can be read in using `ape::read.FASTA()`
or `ape::read.dna()`. NOTE: We do not recommend using this function to extract
more than one founder sequence to initiate a single simulation because
if any gaps are present then the founder sequences will not be the same
length, which will lead to an error.

This alignment is of the entire HIV genome, but we're only interested in the
ENV gp120 gene, which we can subset to using the `start` and `end` arguments.

```{r, extract_seqs}
extract_seqs(hxb2_cons_founder, 'B.US.2011.DEMB11US006.KC473833', start = 6225, end = 7757)
```

This function can also take a reference sequence name (`ref_name`), which can be
used as the input to the `ref_seq` argument in `run_wavess()`. More on this later.

### Determine nucleotide substitution probabilities {#determine-nucleotide-substitution-probabilities}

We provide the function `calc_nt_sub_probs()` to calculate nucleotide 
substitution probabilities, which can be used as input for the `nt_sub_probs`
argument in `run_wavess()`. Ideally, the input for this function would be an
alignment of sequences from within-host evolution of a single
representative person. It takes an alignment in `ape::DNAbin` format and
outputs a data frame of substitution probabilities where the rows are
the "from" nucleotide and the columns are the "to" nucleotide. 
**TODO: ADD AN EXAMPLE WITHIN-HOST ALIGNMENT**

```{r, calc_nt_sub_probs}
calc_nt_sub_probs(as.matrix(hiv_env_flt_2021))
```

By default, a neighbor joining tree is created using
`ape::bionj(ape::dist.dna(aln, model = 'TN93'))`. Instead, you can
provide an input tree (`tr`). From this, the Q matrix is computed with
`phangorn::pml_bb()` using by default a GTR+I+R4 model of nucleotide
substitution (`model`) and no tree rearrangement (`rearrangement`).

## Probabilities

Many of the required inputs are probabilities that various events happen
(e.g. mutation, recombination, latency events). All of these arguments have
the prefix `prob_`. (Note that to "turn off" any 
of these, all you have to do is set the probability equal to 0.)

### Convert rates to probabilities

Much of the time, in the literature, values for events of interest are reported as
*rates*, i.e. the number of events that happen in a given amount of time. 
However, our simulations require *probabilities* of an event occurring in one 
generation. Therefore, we provide a function to convert a per-generation rate
to a per-generation probability:

```{r, rate_to_prob}
rate_to_probability(0.001)
rate_to_probability(0.01)
rate_to_probability(0.1)
rate_to_probability(1)
```

What you'll notice is that the rates and the probabilities are effectively
identical for slow rates, but quite different for faster rates. 

### Visualize latent cell dynamics {#visualize-latent-cell-dynamics}

While the input parameters for latency are simply probabilities, it is
helpful to visualize the latent cell dynamics prior to simulating data
with a given set of probabilties.

The way the model implements latency is stochastic, meaning that a
different number of cells will become latent in each simulation, but the
overall trends should be similar across simulations, given the same set
of probabilities.

To make these plots, you need the active cell counts, which can be
generated from the `generate_pop_sam()` function described above. We
will therefore be using the `pop_samp` dataset we created earlier in the
vignette.

Below is example code you can use to plot the latent cell dynamics given
certain probabilities. 

**Please note that we assume the probabilities are small for all latency rates**,
such that it is unlikely that multiple events (activate, die, proliferate) will
occur to a single latent cell in a single [active cell] generation. 
If multiple events occur to a single latent cell, then the first event in this ordered
list will be chosen as the event that occurred to the cell in that generation:
cell becomes active, cell dies, cell proliferates.

```{r, viz_latent}
# set parameters to get latent curve
to_latent_rate <- 0.001
to_active_rate <- 0.01
proliferation_rate <- 0.01 
death_rate <- 0.01

# get latent cell count for each generation
latent <- 0
active_latent_counts <- lapply(pop_samp$active_cell_count, function(x){
  n_to_latent <- rbinom(1, x, prob = to_latent_rate)
  to_active <- rbinom(latent, 1, prob = to_active_rate)
  to_proliferate <- rbinom(latent, 1, prob = proliferation_rate)
  to_die <- rbinom(latent, 1, prob = death_rate)
  n_to_active <- sum(to_active == 1)
  n_to_die <- sum((to_die - to_active) == 1)
  n_to_proliferate <- sum((to_proliferate - to_die - to_active) == 1)
  counts <- tibble(Active = x, Latent = latent, n_to_latent, n_to_active, n_to_proliferate, n_to_die)
  latent <<- latent + n_to_latent - n_to_active + n_to_proliferate - n_to_die
  return(counts)
}) |> bind_rows() |> 
  mutate(gen = row_number()) 

# Plot (latent) cell counts
active_latent_counts |> 
  pivot_longer(c(Active, Latent)) |> 
  ggplot(aes(x = gen, y = value, col = name)) +
  geom_line() +
  # scale_y_log10() + # uncomment this if you want to scale the y axis by log10
  scale_color_manual(values = c('black', 'red')) +
  labs(x = 'Generation', y = 'Number of infected cells', col = 'Type of cell') 
```

## Selection

`wavess` can simulate three types of selection: conserved sites, fitness relative
to a reference sequence, and B-cell immune selection at user-defined epitopes. 
By default, no selection is included in the simulations. Here, we describe how
to generate the inputs for each of these selective pressures.

**An important note about indexing and reference sequences before we jump in:**

First, everything must be indexed relative to the start of the 
founder sequence in the simulation. Even though the back-end is implemented in
Python, for the `run_wavess()` R function we expect the indexing to begin at 1, 
since this is more intuitive for R users (we account for this internally). If
you would like to use these functions followed by the Python script, you will have
to make sure to change the indexing to 0 for the conserved sites and epitopes
(i.e. subtract 1 from all numbers). 

Second, information of interest such as conserved sites or antibody contacts, 
is often computed or provided relative to what is 
called a reference sequence. For HIV, the reference sequence is usually HXB2. **This
community reference sequence is different than how we define a reference sequence in 
`wavess`.** The community reference sequence (e.g. HXB2) is a standard that 
researchers use to more easily be able to share and compare information. The
reference sequence defined in `wavess` is one that is believed to be 
representative of the "most fit" sequence (when not under immune pressure), 
however you would like to think of it.

When information of interest is provided relative to the community reference
sequence, we must change the indexing of the information to be relative to 
the founder sequence that will be used in the simulation. 

The easiest way to ensure that the indexing is correct is to have an alignment
consisting of the founder sequence, the community reference sequence 
(if needed), and the wavess reference sequence (if being used), where the
start and end of the alignment are the start and end of the founder sequence
to be used in the simulation. 

If you have an alignment with sequences that are longer than
the input sequence you want to simulate, you can use the `slice_aln()` function
to slice out the desired section of the alignment. Here's an example:

**TODO: CONFIRM THAT THE END POSITION IS CORRECT**

```{r, slice_aln}
(gp120 <- slice_aln(hxb2_cons_founder, 6225, 7757))
```

We will use this alignment below. 

### Identify conserved sites

In `run_wavess()` you can provide a vector of conserved sites
(`conserved_sites` argument). Mutations in conserved sites have a
fitness cost defined by the `conserved_cost` argument.

To generate a vector of conserved sites from an alignment, you can use
the function `identify_conserved_sites()`, which outputs a data frame
with 5 columns:

- `founder_pos`: the position in the founder
- `founder_base`: the base in the founder sequence
- `consensus_base`: the consensus base
- `consensus_prop`: the proportion of sequences that have the consensus base
- `conserved`: whether ('Yes') or not ('No') the site is considered
  conserved, based on the threshold value defined by the `thresh`
  argument (default: 0.99)

You can use this function in two ways. If you have an alignment that
includes the founder sequence of interest, all you need to provide is
the alignment in `ape::DNAbin` format and the name of the founder
sequence in the alignment.
Note that the function assumes that the alignment consists of only the segment
of the founder sequence that you want to simulate (i.e., the beginning of the 
alignment is the beginning of the founder sequence that you want to simulate,
and the end of the alignment is the end of the sequence you want to simulate).

We will be using the built-in `hiv_env_flt_2021` alignment as an example.
However, this contains only 10 sequences. **In reality, you should use many more 
sequences.** For HIV, you can download the entire filtered alignment for each gene
or for the entire genome from the [LANL HIV sequence
database](https://www.hiv.lanl.gov/content/sequence/NEWALIGN/align.html). 

For gp120, we also provide a vector of conserved sites in the package for ease of 
use. **TODO: ACTUALLY DO THIS**

First, since the `hxb2_cons_founder` sequence is all of env, but we just want to 
simulate gp120, we have to slice out that part of the alignment:

```{r}
# get hxb2 gp120 end position
len_hxb2_gp120 <- nchar(extract_seqs(hxb2_cons_founder, 'B.FR.83.HXB2_LAI_IIIB_BRU.K03455', start = 6225, end = 7757)$founder)
hxb2_gp120_end <- which(cumsum(as.character(hiv_env_flt_2021[1,]) != '-') == len_hxb2_gp120)
# subset to only gp120 section
hiv_gp120_flt_2021 <- slice_aln(hiv_env_flt_2021, 1, hxb2_gp120_end) 
```

Then we can use this sliced alignment to identify conserved sites:

```{r, conserved}
identify_conserved_sites(hiv_gp120_flt_2021, 'B.FR.83.HXB2_LAI_IIIB_BRU.K03455')
```

Alternatively, if you have two alignments with a shared reference, one
from which you'd like to calculate conserved sites, and the other that
contains the founder, you can provide both alignments, as well as the
common reference, and the function will return the conserved sites
relative to the founder sequence:

```{r, conserved2}
(founder_conserved_df <- identify_conserved_sites(hiv_gp120_flt_2021, 
                         founder = 'B.US.2011.DEMB11US006.KC473833', 
                         ref = 'B.FR.83.HXB2_LAI_IIIB_BRU.K03455', 
                         founder_aln = gp120))
```

You can visualize the conserved sites across the genome using the following code:

```{r, viz_conserved}
founder_conserved_df |> 
  ggplot(aes(x = founder_pos, y = consensus_prop, fill = conserved)) +
  geom_col()
```

The blue sites are conserved, the red sites are not conserved, and the
y-axis indicates the proportion of sequences in the alignment that
contain the consensus base.

While we provide information about each sequence in the output, the
input of `run_wavess` only takes a vector of the conserved sites. To
generate this, you can run the following code:

```{r, prep_conserved}
founder_conserved_sites <- founder_conserved_df |>
  filter(conserved == 'Yes') |>
  pull(founder_pos)

head(founder_conserved_sites)
tail(founder_conserved_sites)
```

We recommend using a large alignment with very diverse sequences to
identify conserved sites, as we do here, to ensure that the identified
sites are across many genetic backgrounds.

### Find a consensus sequence

We have implemented a very crude way of generating a consensus sequence,
by taking the most common base at each position, and if there is a tie,
the base that comes first in the alphabet. The consensus sequence is
returned as part of the `identify_conserved_sites()` output. If you
would like more control over generating a consensus sequence, you can
use the [Consensus
Maker](https://www.hiv.lanl.gov/content/sequence/CONSENSUS/consensus.html)
tool on the LANL HIV website.

To convert the consensus sequence from above into the correct input
format for `run_wavess()`, you can use the following code, where NA values
are converted to gaps:

```{r, prep_founder}
gsub('NA', '-', paste0(founder_conserved_df$consensus_base, collapse = ''))
```

**TODO: CHECK TO SEE IF THIS NEEDS TO BE UPPERCASE/DECIDE IF WE WANT IT TO HAVE TO BE UPPERCASE**

If you have an alignment including the founder sequence and wavess reference
sequence you'd like to use, then you can also use the `extract_seqs()` function
to obtain both at once:

```{r}
(founder_ref <- extract_seqs(hxb2_cons_founder, 
             founder = 'B.US.2011.DEMB11US006.KC473833', 
             ref = 'CON_B(1295)',
             start = 6225, end = 7757))
```

It's okay if the reference sequence has gaps. These will be ignored when 
computing fitness relative to the reference.

### Sample epitopes

Immune fitness in `wavess` is defined by epitope locations in the
sequence, each of which can have a maximum fitness cost between 0 and 1.
These are defined at the amino acid level, so they must be within a nucleotide
sequence that is translated to a protein. 

While you can define your own epitope locations, we provide the function
`sample_epitopes()` that, given epitope probabilities for each *amino acid* 
position of interest, will return randomly sampled epitope
locations based on the probability of an epitope occurring at that
location. Therefore, the function `sample_epitopes()` takes as input a
data frame that must contain columns for the amino acid position
(`aa_position`) and the epitope probability at that position
(`epitope_probability`)

If possible, we recommend determining epitope probabilities based on
some sort of known antibody contact/binding/neutralization maps. For HIV
ENV, we used the features from the LANL HIV immunology database:

```{r}
env_features
```

All we need is the positions column, but we provide the rest of the
information for reference.

If you don't have this information, you can use uniformly distributed probabilities,
or some other informed guess as to where the probabilities for epitopes binding
is higher. 

We can put the positions into the `get_epitope_frequencies()` function,
which returns a tibble with three columns:

- `aa_pos`: amino acid position
- `n_features`: the number of features at that position
- `epitope_probability`: the probability of an epitope at that
  position, given the input positions

```{r}
(epi_probs <- get_epitope_frequencies(env_features$position))
```

**TODO: FIGURE OUT WHERE gp120 ENDS AND ONLY SAMPLE FROM THAT SECTION**

This information can be used as input to the `sample_epitopes()`
function. Note that the output of this function is different each time
it's run, since the locations are selected randomly each time.

```{r}
sample_epitopes(epi_probs)
```

The function returns start and end *nucleotide* positions for each epitope,
relative to the input amino acid positions. 

There are many ways to customize the output of this function. You can
provide the starting (`start_aa_pos`) and ending (`end_aa_pos`) amino
acid positions to consider for epitope sampling (here we've pre-subset to only 
gp120 features), the number of epitopes to sample (`num_epitopes`), the amino 
acid epitope length (`aa_epitope_length`), the maximum fitness cost of the epitope
(`max_fit_cost`), and the cost type (linear or random, see documentation for
details). 

If the amino acid positions are relative to a community reference sequence,
then you will also need to create a map between the community reference and your
founder sequence so that the data can be re-indexed to the founder sequence.
In this case, the amino acid positions we used are from HXB2, so we want to
map them to our founder sequence.
You should use the alignment that contains the exact founder sequence you plan
to simulate (no longer and no shorter). Once you have this alignment (e.g.
using the `slice_aln()` function described above), you can the `map_ref_founder()` 
function, which returns reference and founder positions mapped to each other:

```{r}
(ref_founder_map <- map_ref_founder(gp120, 
                ref = 'B.FR.83.HXB2_LAI_IIIB_BRU.K03455', 
                founder = 'B.US.2011.DEMB11US006.KC473833'))
```

You can input this into `sample_epitopes()`, which will then return nucleotide
positions relative to the founder sequence (instead of HXB2):

```{r}
(epitope_locations <- sample_epitopes(epi_probs, ref_founder_map = ref_founder_map))
```

Here are two ways to visualize the epitopes:

```{r}
epitope_locations |> 
  ggplot(aes(x = epi_start_nt, y = max_fitness_cost)) +
  geom_point() +
  labs(x = 'Epitope start position', y = 'Max fitness cost')

epitope_locations %>%
  ggplot(aes(x = 1:nrow(.), y = max_fitness_cost, col = epi_start_nt)) +
  geom_point() +
  labs(x = 'Epitope', y = 'Max fitness cost', col = 'Epitope start\nposition')
```


