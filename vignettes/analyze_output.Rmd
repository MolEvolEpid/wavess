---
title: "Analyze wavess output"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Analyze wavess output}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

In this vignette, we'll provide various ways to analyze the output of `run_wavess()`.
Note that many of these functions can also be used to analyze real-world
empirical data. 

For simulated data, we highly recommend comparing the output to empirical data,
or at least using your domain knowledge to determine whether the output seems
reasonable. If it doesn't, you may have to tweak various input parameters to 
get believable outputs. The default input parameters we provide generally 
lead to a reasonable output for HIV, but even so, due to the stochastic nature
of the model, some outputs look more like real data than others.

## Run wavess

First, let's run wavess including all the selective pressures. 
For more details on the input and running wavess,
please see the respective vignettes. (`vignette(prepare_input_data)` and 
`vignette(run_wavess)`)

```{r setup}
library(wavess)
library(dplyr)
library(ggplot2)
library(tidyr)
library(ape)
library(phangorn)
library(ggtree)

hiv_env_flt_2021 <- as.matrix.DNAbin(hiv_env_flt_2021)
hxb2_cons_founder <- as.matrix.DNAbin(hxb2_cons_founder)

pop_samp <- generate_pop_samp(gN = 300, sampling_frequency = 100)
founder_ref <- extract_seqs(hxb2_cons_founder, 
             founder = 'B.US.2011.DEMB11US006.KC473833', 
             ref = 'CON_B(1295)',
             start = 6225, end = 7757)
nt_sub_probs <- calc_nt_sub_probs(as.matrix(hiv_env_flt_2021)[1:10,])
hiv_gp120_flt_2021 <- slice_aln(hiv_env_flt_2021, 1, 2517) 
gp120 <- slice_aln(hxb2_cons_founder, 6225, 7757)
founder_conserved_sites <- identify_conserved_sites(hiv_gp120_flt_2021, 
                         founder = 'B.US.2011.DEMB11US006.KC473833', 
                         ref = 'B.FR.83.HXB2_LAI_IIIB_BRU.K03455', 
                         founder_aln = gp120) |>
  filter(conserved == 'Yes') |>
  pull(founder_pos)
epi_probs <- get_epitope_frequencies(env_features$position)
ref_founder_map <- map_ref_founder(gp120, 
                ref = 'B.FR.83.HXB2_LAI_IIIB_BRU.K03455', 
                founder = 'B.US.2011.DEMB11US006.KC473833')
epitope_locations <- sample_epitopes(epi_probs, ref_founder_map = ref_founder_map)

founder_ref$ref <- gsub('N', '-', founder_ref$ref)
wavess_out <- run_wavess(pop_samp = pop_samp, 
                            founder_seqs = founder_ref$founder, 
                            nt_sub_probs = nt_sub_probs,
                            conserved_sites = founder_conserved_sites,
                            ref_seq = founder_ref$ref,
                            epitope_locations = epitope_locations)
```

**WHY IS IT SOO MUCH SLOWER WHEN DOING MULTIPLE FITNESSES COMPARED TO JUST ONE?**
seems like conserved + ref_seq is the culprit

## Plotting counts

```{r}
wavess_out$counts |> 
  pivot_longer(!generation) |> 
  ggplot(aes(x = generation, y = value)) +
  facet_wrap(~name, scales = 'free') +
  geom_line()
```

## Diversity and divergence

Within-generation diversity and divergence from the founder sequence across time 
can be computed and plotted as follows 
(reference for calculations 
[here](https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1004625)):

```{r}
gens <- gsub('gen_|_cell.*', '', labels(wavess_out$seqs))
div_metrics <- calc_div_metrics(wavess_out$seqs, 'founder1', gens)

div_metrics |> 
  mutate(gen = as.numeric(gen)) |> 
  pivot_longer(!gen) |> 
  ggplot(aes(x = gen, y = value)) +
  facet_grid(~name) +
  geom_line()
```


## Phylogeny

While you may want to use a different tree-building algorithm outside of R such
as [IQ-TREE](http://www.iqtree.org/), here is a way to quickly build a tree in 
R using `ape` to generate a neighbor-joining tree and `phangorn` to estimate
branch lengths using maximum likelihood:

```{r}
pml_out <- phangorn::pml_bb(wavess_out$seqs, start = bionj(dist.dna(wavess_out$seqs, model = "TN93")), model = "GTR+R(4)+I", rearrangement = 'none')

tr <- root(pml_out$tree, 'founder1')
gens <- gsub('gen_|_cell.*', '', tr$tip.label)
ggtree(tr) +
  geom_tippoint(aes(col = c(gens, rep(NA, Nnode(tr))))) +
  scale_color_brewer(palette = 'Set1') +
  geom_treescale() +
  labs(col = 'Generation')
```

## Phylogeny summary statistics

Using the tree generated above, we provide the functionality to compute three
relevant summary statistics:

- The [Sackin index](https://treebalance.wordpress.com/sackin-index/) normalized 
by the number of tree tips (to be able to compare values across trees of different sizes).
- The ratio between the mean internal branch length and the mean external branch
length.
- The mean proportion of lineages that survived from one generation to the next.
**CHECK WITH THOMAS TO SEE IF WE SHOULD JUST KEEP THE CURRENT AND PREVIOUS GENERATION IN THE CALCULATION**

Many other tree statistics can be calculated using the 
[`treebalance`](https://treebalance.wordpress.com/) package.

```{r}
gens_numeric <- as.numeric(gens)
names(gens_numeric) <- tr$tip.label
gens_numeric <- gens_numeric[!is.na(gens_numeric)]
calc_tr_summary_stats(tr, gens_numeric)
```

Each of these can also individually be computed using the following functions:
`calc_sackin_norm()`, `calc_int_over_ext()`, and `calc_prop_survived()`.
