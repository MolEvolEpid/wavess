---
title: "Analyze wavess output"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Analyze wavess output}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

In this vignette, we'll provide various ways to analyze the output of
`run_wavess()`. Note that many of these functions can also be used to analyze
real-world empirical data.

For simulated data, we highly recommend comparing the output to empirical data,
or at least using your domain knowledge to determine whether the output seems
reasonable. If it doesn't, you may have to tweak various input parameters to 
get believable outputs. The default input parameters we provide generally 
lead to a reasonable output for HIV, but even so, due to the stochastic nature
of the model, some outputs look more like real data than others.

## Run wavess

First, let's load the relevant libraries, set the default plotting theme, and
run wavess including all the selective pressures.
We're going to set a seed for reproducibility.
For more details on the input and running wavess,
please see the respective vignettes. (`vignette("prepare_input_data")` and 
`vignette("run_wavess")`). If you haven't checked out those vignettes first, be
sure to at least run the `create_python_venv()` function prior to running the 
below code, or else you'll get an error telling you to do so. 

```{r setup}
library(wavess)
library(dplyr)
library(ggplot2)
library(tidyr)
library(ape)
library(phangorn)
library(ggtree)

set.seed(1234)

theme_set(theme_classic() +
  theme(strip.background = element_rect(color = "white")))

# if needed
create_python_venv()

pop_samp <- generate_pop_samp(
  n_gen = 500,
  sampling_frequency = 30,
  max_samp = 50
)
founder_ref <- extract_seqs(hxb2_cons_founder,
  founder = "B.US.2011.DEMB11US006.KC473833",
  ref = "CON_B(1295)",
  start = 6225, end = 7787
)
gp120 <- slice_aln(hxb2_cons_founder, 6225, 7787)
epi_probs <- get_epitope_frequencies(env_features$Position)
ref_founder_map <- map_ref_founder(gp120,
  ref = "B.FR.83.HXB2_LAI_IIIB_BRU.K03455",
  founder = "B.US.2011.DEMB11US006.KC473833"
)
epitope_locations <- sample_epitopes(epi_probs,
  ref_founder_map = ref_founder_map
)

wavess_out <- run_wavess(
  pop_samp = pop_samp, 
  founder_seqs = founder_ref$founder,
  conserved_sites = conserved_sites,
  ref_seq = founder_ref$ref,
  epitope_locations = epitope_locations,
  seed = 1234
)
```

## Plotting counts

Here are various counts plotted over time:

```{r, plot_counts}
wavess_out$counts |>
  pivot_longer(!generation) |>
  ggplot(aes(x = generation, y = value)) +
  facet_wrap(~name, scales = "free") +
  geom_line()
```

## Diversity and divergence

Within-generation diversity and divergence from the founder sequence across time 
can be computed and plotted as follows 
(reference for calculations 
[here](https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1004625)):

```{r, get_div_mets}
gens <- gsub("gen_|_cell.*", "", labels(wavess_out$seqs))
(div_metrics <- calc_div_metrics(wavess_out$seqs, "founder0", gens))
```

As can be seen, the diversity of founder0 and generation 0 are NaN. This is because
there is only one sampled sequence at those timepoints, so diversity cannot be
computed.

```{r, plot_div}
div_metrics |>
  mutate(gen = as.numeric(gen)) |>
  pivot_longer(!gen) |>
  ggplot(aes(x = gen, y = value)) +
  facet_grid(~name) +
  geom_line()
```


## Phylogeny

**We HIGHLY recommend using a maximum-likelihood (or Bayesian) tree-building 
algorithm outside of R such as [IQ-TREE](http://www.iqtree.org/) for your
tree-based analyses of the simulated sequences.** That being said, it is
sometimes nice, like here, to build a quick tree to get a sense of what the
output of your simulations looks like. Below is a way to quickly build a tree in
R using `ape` to generate a neighbor-joining tree and `phangorn` to estimate
branch lengths using maximum likelihood. (Note that you can also modify the
below code to estimate a full maximum-likelihood tree in R by deleting 
`rearrangement = "none"`, just be prepared for it to take a long time to run - 
longer than it would take to run IQ-TREE.)

```{r, plot_tree}
pml_out <- pml_bb(wavess_out$seqs,
  start = bionj(dist.dna(wavess_out$seqs, model = "TN93")),
  model = "GTR+I+R(4)", rearrangement = "none"
)

tr <- root(pml_out$tree, "founder0", resolve.root = TRUE)
gens <- gsub("gen_|_cell.*", "", tr$tip.label)
names(gens) <- tr$tip.label
ggtree(tr) +
  geom_tippoint(aes(col = factor(c(gens, rep(NA, Nnode(tr))), levels = c('founder0', sort(unique(as.numeric(gens))))))) +
  scale_color_brewer(palette = "Set1") +
  geom_treescale() +
  labs(col = "Generation")
```

## Phylogeny summary statistics

Using the tree generated above, we provide the functionality to compute three
relevant summary statistics:

- The [Sackin index](https://treebalance.wordpress.com/sackin-index/) normalized
by the number of tree tips (to be able to compare values across trees of
different sizes).
- The ratio between the mean internal branch length and the mean external branch
length.
- The parsimony score of the phylogeny with the tips labeled as timepoints.
Many other tree statistics can be calculated using the
[`treebalance`](https://treebalance.wordpress.com/) package.

**Note that these summary statistics can only be compared for trees that are
derived from the same sampling scheme, i.e. the same number of samples taken
at the same time points post-infection.**

```{r, tr_summary_stats}
calc_tr_summary_stats(tr, gens)
```

Each of these can also individually be computed using the following functions:
`calc_sackin()`, `calc_int_over_ext()`, and `calc_parsimony()`.

